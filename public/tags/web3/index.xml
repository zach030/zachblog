<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>web3 on ZachBlog</title>
    <link>https://www.bayesfame.xyz/tags/web3/</link>
    <description>Recent content in web3 on ZachBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ch</language>
    <copyright>Copyright © 2008–2019, Steve Francia and the lee.so; all rights reserved.</copyright>
    <lastBuildDate>Fri, 24 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.bayesfame.xyz/tags/web3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>详解nostr：nip-05</title>
      <link>https://www.bayesfame.xyz/post/nip-05/</link>
      <pubDate>Fri, 24 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.bayesfame.xyz/post/nip-05/</guid>
      <description>NIP-05 将Nostr密钥映射到基于 DNS 的互联网标识符 在事件类型 set_metadata中，用户可以设置一个互联网标识符（像邮箱一样的地址）作为nip05的值
尽管这里指向互联网标识符的链接非常自由，但NIP-05设定&amp;lt;local-part&amp;gt;部分被限制在字符a-z0-9-_.中
客户端会将标识符分为&amp;lt;local-part&amp;gt; 和 &amp;lt;domain&amp;gt;两部分，并且使用这些值去构造一个GET请求，目标地址为：https://&amp;lt;domain&amp;gt;/.well-known/nostr.json?name=&amp;lt;local-part&amp;gt;
请求的响应值应该是带有names键的json对象，names键应该是一个从用户名到16进制字符串的映射，如果names中对应的公钥和set_metadata事件中的公钥一致，那么客户端会认为给定的公钥确实可以由其标识符引用
示例 客户端接收到如下格式的事件：
{ &amp;quot;pubkey&amp;quot;: &amp;quot;b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9&amp;quot;, &amp;quot;kind&amp;quot;: 0, &amp;quot;content&amp;quot;: &amp;quot;{\&amp;quot;name\&amp;quot;: \&amp;quot;bob\&amp;quot;, \&amp;quot;nip05\&amp;quot;: \&amp;quot;bob@example.com\&amp;quot;}&amp;quot; ... } 客户端将会向https://example.com/.well-known/nostr.json?name=bob 发送GET请求，并且收到的响应值结果应该是：
{ &amp;quot;names&amp;quot;: { &amp;quot;bob&amp;quot;: &amp;quot;b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9&amp;quot; } } 或者是带有可选的relays属性：
{ &amp;quot;names&amp;quot;: { &amp;quot;bob&amp;quot;: &amp;quot;b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9&amp;quot; }, &amp;quot;relays&amp;quot;: { &amp;quot;b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9&amp;quot;: [ &amp;quot;wss://relay.example.com&amp;quot;, &amp;quot;wss://relay2.example.com&amp;quot; ] } } 通过NIP-05标识符找到用户 客户端可以实现从互联网标识符中查找用户的公钥，流程与上面一样，但是相反: 首先客户端获取已知的 URL，然后从那里获取用户的公钥，然后它尝试为该用户获取类型为0的事件，并检查它是否有一个匹配的“ nip05”。
备注 客户端必须始终遵循公钥，而不是 NIP-05地址 例如，在发现bob@bob.com有公钥abc...def后，用户点击按钮进行关注，客户端必须保持对abc...def的追踪而不是bob@bob.com。如果出于任何原因，地址https://bob.com/.well-known/nostr.json?name=bob在未来的某个时刻所对应的公钥变为1d2...e3f，客户端不应该在用户的关注列表中替换公钥abc...def（但是应该停止展示bob@bob.com，因为它变成了无效的nip05属性）
公钥必须是16进制格式 公钥必须以十六进制格式返回。NIP-19 npub 格式的密钥只能用于在客户端 UI 中显示，而不能在此 NIP 中显示。
支持用户搜索 客户端应该允许用户去搜索他人的主页，如果客户端有一个搜索框，用户可能会输入bob@example.com ，并且客户端会识别并发送请求获取他的公钥返回给用户</description>
    </item>
    
    <item>
      <title>详解nostr：nip-04</title>
      <link>https://www.bayesfame.xyz/post/nip-04/</link>
      <pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.bayesfame.xyz/post/nip-04/</guid>
      <description>NIP-04 加密的私信 事件类型为4的含义是“加密的私信”，它应该有以下特质： content内容：用户将想要发送的内容通过将收件人的公开密钥与发件人的私人密钥相结合而生成的共享密码，基于aes-256-cbc加密算法进行加密，再经过base64编码生成的。这是由 base64编码的初始向量所附加的，就好像它是一个名为“ iv”的查询参数一样。格式如下：&amp;quot;content&amp;quot;: &amp;quot;&amp;lt;encrypted_text&amp;gt;?iv=&amp;lt;initialization_vector&amp;gt;&amp;quot;.
tags必须包含一个记录可以标识消息的接收方，这样，中继器可以自然地将这一事件转发给他们，格式如下：[&amp;quot;p&amp;quot;, &amp;quot;&amp;lt;pubkey, as a hex string&amp;gt;&amp;quot;]
tags可能包含在之前对话中的消息，或者是我们明确回复的消息，格式如下：[&amp;quot;e&amp;quot;, &amp;quot;&amp;lt;event_id&amp;gt;&amp;quot;]</description>
    </item>
    
    <item>
      <title>详解nostr：nip-03</title>
      <link>https://www.bayesfame.xyz/post/nip-03/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.bayesfame.xyz/post/nip-03/</guid>
      <description>NIP-03 OpenTimestamps事件认证 当存在 OTS 时，它应该包含在 ots 键下的现有事件主体中:
{ &amp;quot;id&amp;quot;: ..., &amp;quot;kind&amp;quot;: ..., ..., ..., &amp;quot;ots&amp;quot;: &amp;lt;base64-encoded OTS file data&amp;gt; } 事件 id 必须用作 OpenTimestamp merkle 树中包含的原始hash散列。
认证可以由中继器自动提供(OTS 二进制内容附加到接收到的事件中) ，也可以由客户端自己在第一次将事件上传到中继器时提供，并由客户端用来表明事件真的“至少与(OTS 日期)一样古老”。</description>
    </item>
    
    <item>
      <title>详解nostr：nip-02</title>
      <link>https://www.bayesfame.xyz/post/nip-02/</link>
      <pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.bayesfame.xyz/post/nip-02/</guid>
      <description>NIP-02 联系人列表和昵称 具有 kind 3的特殊事件(意思是“联系人列表”)定义为具有一个 p 标记列表，每个 p 标记对应于所关注的/已知的联系人简介。
每个标记条目应该包含联系人简介的键，一个可以找到来自该键的事件的中继器 URL (如果不需要，可以设置为空字符串) ，以及该联系人简介的本地昵称(或“ petname”)(也可以设置为空字符串或不提供) ，即，[“p”，&amp;lt; 32-bytes hex key &amp;gt; ，&amp;lt; main relay URL &amp;gt; ，&amp;lt; petname &amp;gt; ]。content可以是任何内容，应该被忽略。
示例：
{ &amp;quot;kind&amp;quot;: 3, &amp;quot;tags&amp;quot;: [ [&amp;quot;p&amp;quot;, &amp;quot;91cf9..4e5ca&amp;quot;, &amp;quot;wss://alicerelay.com/&amp;quot;, &amp;quot;alice&amp;quot;], [&amp;quot;p&amp;quot;, &amp;quot;14aeb..8dad4&amp;quot;, &amp;quot;wss://bobrelay.com/nostr&amp;quot;, &amp;quot;bob&amp;quot;], [&amp;quot;p&amp;quot;, &amp;quot;612ae..e610f&amp;quot;, &amp;quot;ws://carolrelay.com/ws&amp;quot;, &amp;quot;carol&amp;quot;] ], &amp;quot;content&amp;quot;: &amp;quot;&amp;quot;, ...other fields 每个新的联系人列表在发送时会覆盖之前的，所以这里是全量的数据。中继器和客户端应该在收到联系人列表后删除过去的。
用途 联系人备份 如果用户相信一个中继将存储他们的事件足够的时间，他们可以使用这种kind-3事件备份他们的关注者清单和在不同的设备恢复。
发现联系人和拓展内容 一个客户端可能依赖于 kind-3事件来显示一个被关注的人的名单，根据他正在浏览的个人资料; 根据他可能关注或浏览的其他人的联系人列表来建议关注谁; 或者显示其他上下文中的数据。
分享中继器 一个客户端可能会发布一个完整的联系人列表，并为每个联系人提供良好的中继服务，这样其他客户端就可以根据需要更新他们的内部中继服务列表，从而增强对审查制度的抵抗力。
昵称方案 客户端可以使用这些联系人列表中的数据构造从其他人的联系人列表中派生出来的本地“ petname”表。这减轻了对全局人眼可读名称的需求。例如: 用户有一个内部联系人列表：
[ [&amp;quot;p&amp;quot;, &amp;quot;21df6d143fb96c2ec9d63726bf9edc71&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;erin&amp;quot;] ] 并接收两个联系人列表，其中一个来自21df6d143fb96c2ec9d63726bf9edc71</description>
    </item>
    
    <item>
      <title>详解nostr：nip-01</title>
      <link>https://www.bayesfame.xyz/post/nip-01/</link>
      <pubDate>Sun, 19 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.bayesfame.xyz/post/nip-01/</guid>
      <description>NIP-01 基本的协议描述 这个 NIP 定义了每个人都应该实现的基本协议。新的 NIP 可能会向这里描述的结构和流添加新的可选(或强制)字段、消息和特性。
事件和签名 每个用户有公私钥对，签名，公钥，编码是基于 secp256k1 圆锥曲线实现的 event对象类型的定义如下：
{ &amp;#34;id&amp;#34;: &amp;lt;32-bytes lowercase hex-encoded sha256 of the the serialized event data&amp;gt; &amp;#34;pubkey&amp;#34;: &amp;lt;32-bytes lowercase hex-encoded public key of the event creator&amp;gt;, &amp;#34;created_at&amp;#34;: &amp;lt;unix timestamp in seconds&amp;gt;, &amp;#34;kind&amp;#34;: &amp;lt;integer&amp;gt;, &amp;#34;tags&amp;#34;: [ [&amp;#34;e&amp;#34;, &amp;lt;32-bytes hex of the id of another event&amp;gt;, &amp;lt;recommended relay URL&amp;gt;], [&amp;#34;p&amp;#34;, &amp;lt;32-bytes hex of the key&amp;gt;, &amp;lt;recommended relay URL&amp;gt;], ... // other kinds of tags may be included later  ], &amp;#34;content&amp;#34;: &amp;lt;arbitrary string&amp;gt;, &amp;#34;sig&amp;#34;: &amp;lt;64-bytes signature of the sha256 hash of the serialized event data, which is the same as the &amp;#34;id&amp;#34; field&amp;gt; } 为了获取event中的id，需要对整个event进行序列化并进行sha256编码，序列化的方式是对下面的结构进行utf8格式的json序列化</description>
    </item>
    
  </channel>
</rss>
